

// This project implements a discrete time dynamic system with analog input and analog (PWM) output.
// It has 1kHz sampling rate for the dynamics and 100kHz for the PWM.
// Analog conversion is triggered by the SCT0 Low counter, and PWM is generated by the SCT0 High counter.

// AO 2023

#include "LPC824.h"
#include "fsl_device_registers.h"
#include "pin_mux.h"
#include "xprintf.h"

#include "fsl_adc.h"
#include "fsl_power.h"

#include "peripherals.h"
#include "dynamic_params.h"



disc_plant_t plant;   // Define the plant type.

// The pointer and flag are global so that ISR can manipulate them:
adc_result_info_t *volatile ADCResultPtr; 
volatile bool ADCConvCompleteFlag;


int main(void) {
  
  uint32_t frequency = 0U;
  adc_result_info_t ADCResultStruct;

  // Set the plant parameters, and initialize the state.
  plant.a1=A1;
  plant.a2=A2;
  plant.b1=B1;
  plant.b2=B2;
  plant.y=0;
  plant.yz=0;
  plant.yz2=0;
  plant.uz=0;
  plant.uz2=0;
  
  ADCResultPtr = &ADCResultStruct; // The global pointer points to this variable
  

  InitPins();
  clock_init();    // Set clock speed to 30MHz
  config_uart0();  // Configure UART0 for correct speed and byte format.
  xdev_out(uart_putch); // Set the hardware interface function for xprintf
  

  xprintf("\n\n\n\r");
  xprintf("**********************************\n\r");
  xprintf("HIL Plant model.\r\n");
  xprintf("The plant transfer function is:\r\n");

  xprintf(" Y(z)        b1*z^(-1) + b2*z(-2) \r\n");
  xprintf("----- = --------------------------\r\n");
  xprintf(" U(z)     1+ a1*z^(-1) + a2*z(-2) \r\n");

  CLOCK_EnableClock(kCLOCK_Sct);  // Enable clock of sct.
  SCT_Config_ADC_Trig();          // Config the half SCT0 which trigs the ADC.
  SCT_Config_PWM();               // Config the half SCT0 which generates PWM.
  
  CLOCK_EnableClock(kCLOCK_Adc);      // Enable ADC clock

  POWER_DisablePD(kPDRUNCFG_PD_ADC0); // Power on ADC0
  
  // Hardware calibration is required after each chip reset.
  // See: Sec. 21.3.4 Hardware self-calibration
  frequency = CLOCK_GetFreq(kCLOCK_Irc);

  if (true == ADC_DoSelfCalibration(ADC0, frequency)) {
    xprintf("ADC Calibration Done.\r\n");
  } else {
    xprintf("ADC Calibration Failed.\r\n");
  }
  

  ADC_Configuration(&ADCResultStruct);    // Configure ADC and operation mode.
  
  // Enable the interrupt the for Sequence A Conversion Complete:
  ADC_EnableInterrupts(ADC0, kADC_ConvSeqAInterruptEnable); // Within ADC0
  NVIC_EnableIRQ(ADC0_SEQA_IRQn);                           // Within NVIC
  
  xprintf("Configuration Done.\r\n\n");

  while (1) {
    
  } 

} // END: main()


//ISR for ADC conversion sequence A done.
void ADC0_SEQA_IRQHandler(void) {

  uint16_t PWM_duty;
  
  if (kADC_ConvSeqAInterruptFlag ==
      (kADC_ConvSeqAInterruptFlag & ADC_GetStatusFlags(ADC0))) {
    
    ADC_GetChannelConversionResult(ADC0, ADC_CHANNEL, ADCResultPtr);
    
    ADC_ClearStatusFlags(ADC0, kADC_ConvSeqAInterruptFlag);
    
    //ADCResultPtr->channelNumber;
    //ADCResultPtr->result;


    // Run the discrete dynamics 1 time step:
    // 1. Convert the ADC measurement to a range between (-25.0,25.0)
    //    (0,4095) -> (-25,25) with '0' -> 2047
    // The last value is scaling: 25/2047
    plant.u= ((float)(((int16_t)ADCResultPtr->result)-ADC_INPUT_CONV_OFFSET))*ADC_INPUT_CONV_GAIN;
    
    // 2. Run the plant, obtain putput value:
    plant.y = -plant.a1*plant.yz-plant.a2*plant.yz2+plant.b1*plant.uz+plant.b2*plant.uz2;

    // The input and output ranges are limited, and cannot represent
    //  values greater than a certain limit. Output can only be in the
    //  range (-2,2).
    // We limit check. (The calculations can be performed beyond that limit,
    //  but since the output cannot be represented, the control loop would
    //  not function correctly.):
    if (plant.y > Y_MAX){
      plant.y = Y_MAX;
    }else if (plant.y < Y_MIN){
      plant.y = Y_MIN;
    }

    // Calculate the delay elements:
    plant.yz2=plant.yz;
    plant.yz=plant.y;

    plant.uz2=plant.uz;
    plant.uz=plant.u;

    // 3. Convert the output to a PWM value s.t.
    //    (-2.0,2.0) is converted to (0,300) with 0 converted to 150.
    //    PWM_duty = plant.y*75+150;
    PWM_duty = (uint16_t)(plant.y*PWM_DUTY_CONV_GAIN)+PWM_DUTY_CONV_OFFSET;
    
    //  4. Set PWM value with the result:

    SCT_Set_PWM(PWM_duty);
    
    ADCConvCompleteFlag = true;  // Perhaps it may be used.
  }
}


